        <div class="postArticle-content js-postField js-notesSource js-trackedPost" data-post-id="8492bd8afadc" data-source="post_page" data-collection-id="336d898217ee" data-tracking-context="postPage">
                            <section name="7b72" class="section section--body section--first">
                                <div class="section-divider">
                                    <hr class="section-divider">
                                </div>
                                <div class="section-content">
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <h1 name="01f6" id="01f6" class="graf graf--h3 graf--leading graf--title">Scaling Node.js Applications</h1>
                                        <h2 name="c5dd" id="c5dd" class="graf graf--h4 graf-after--h3 graf--subtitle">Everything you need to know about Node.js built-in tools for scalability</h2></div>
                                    <div class="section-inner sectionLayout--outsetColumn">
                                        <figure name="8a1d" id="8a1d" class="graf graf--figure graf--layoutOutsetCenter graf-after--h4">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 451px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 45.1%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*5zOn0-deg1nQ5YzxUFGCPA.png" data-width="1480" data-height="668" data-action="zoom" data-action-value="1*5zOn0-deg1nQ5YzxUFGCPA.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*5zOn0-deg1nQ5YzxUFGCPA.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1000/1*5zOn0-deg1nQ5YzxUFGCPA.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1000/1*5zOn0-deg1nQ5YzxUFGCPA.png"></noscript>
                                                </div>
                                            </div>
                                            <figcaption class="imageCaption">Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="cd17" id="cd17" class="graf graf--p graf-after--figure">Scalability in Node.js is not an afterthought. It’s something that’s baked into the core of the runtime. Node is named Node to emphasize the idea that a Node application should comprise multiple small distributed <em class="markup--em markup--p-em">nodes</em> that communicate with each other.</p>
                                        <p name="3878" id="3878" class="graf graf--p graf-after--p">Are you running multiple nodes for your Node applications? Are you running a Node process on every CPU core of your production machines and load balancing all the requests among them? Did you know that Node has a built-in module to help with that?</p>
                                        <p name="cb38" id="cb38" class="graf graf--p graf-after--p">Node’s <em class="markup--em markup--p-em">cluster</em> module not only provides an out-of-the-box solution to utilizing the full CPU power of a machine, but it also helps with increasing the availability of your Node processes and provides an option to restart the whole application with a zero downtime. This article covers all that goodness and more.</p>
                                        <blockquote name="fc86" id="fc86" class="graf graf--pullquote graf-after--p">This article is a write-up of part of <a href="https://www.pluralsight.com/courses/nodejs-advanced" data-href="https://www.pluralsight.com/courses/nodejs-advanced" class="markup--anchor markup--pullquote-anchor" rel="noopener" target="_blank">my Pluralsight course about Node.js</a>. I cover similar content in video format there.</blockquote>
                                        <h3 name="99b6" id="99b6" class="graf graf--h3 graf-after--pullquote">Strategies of Scalability</h3>
                                        <p name="ade5" id="ade5" class="graf graf--p graf-after--h3">The workload is the most popular reason we scale our applications, but it’s not the only reason. We also scale our applications to increase their availability and tolerance to failure.</p>
                                        <p name="9f2a" id="9f2a" class="graf graf--p graf-after--p">There are mainly three different things we can do to scale an application:</p>
                                        <h4 name="1443" id="1443" class="graf graf--h4 graf-after--p">1 — Cloning</h4>
                                        <p name="179d" id="179d" class="graf graf--p graf-after--h4">The easiest thing to do to scale a big application is to clone it multiple times and have each cloned instance handle part of the workload (with a load balancer, for example). This does not cost a lot in term of development time and it’s highly effective. This strategy is the minimum you should do and Node.js has the built-in module, <code class="markup--code markup--p-code">cluster</code>, to make it easier for you to implement the cloning strategy on a single server.</p>
                                        <h4 name="026b" id="026b" class="graf graf--h4 graf-after--p">2 — Decomposing</h4>
                                        <p name="6618" id="6618" class="graf graf--p graf-after--h4">We can also scale an application by <a href="https://builttoadapt.io/whats-your-decomposition-strategy-e19b8e72ac8f" data-href="https://builttoadapt.io/whats-your-decomposition-strategy-e19b8e72ac8f" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">decomposing</a> it based on functionalities and services. This means having multiple, different applications with different code bases and sometimes with their own dedicated databases and User Interfaces.</p>
                                        <p name="6fa8" id="6fa8" class="graf graf--p graf-after--p">This strategy is commonly associated with the term <em class="markup--em markup--p-em">Microservice</em>, where micro indicates that those services should be as small as possible, but in reality, the size of the service is not what’s important but rather the enforcement of loose coupling and high cohesion between services. The implementation of this strategy is often not easy and could result in long-term unexpected problems, but when done right the advantages are great.</p>
                                        <h4 name="189a" id="189a" class="graf graf--h4 graf-after--p">3 — Splitting</h4>
                                        <p name="fff9" id="fff9" class="graf graf--p graf-after--h4">We can also split the application into multiple instances where each instance is responsible for only a part of the application’s data. This strategy is often named <em class="markup--em markup--p-em">horizontal partitioning</em>, or <em class="markup--em markup--p-em">sharding</em>, in databases. Data partitioning requires a lookup step before each operation to determine which instance of the application to use. For example, maybe we want to partition our users based on their country or language. We need to do a lookup of that information first.</p>
                                        <p name="9ef3" id="9ef3" class="graf graf--p graf-after--p">Successfully scaling a big application should eventually implement all three strategies. Node.js makes it easy to do so but I am going to focus on the cloning strategy in this article and explore the built-in tools available in Node.js to implement it.</p>
                                        <p name="7b6b" id="7b6b" class="graf graf--p graf-after--p">Please note that you need a good understanding of Node.js <em class="markup--em markup--p-em">child processes </em>before reading this article. If you haven’t already, I recommend that you read this other article first:</p>
                                        <div name="3f5c" id="3f5c" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.freecodecamp.org/node-js-child-processes-everything-you-need-to-know-e69498fe970a" data-href="https://medium.freecodecamp.org/node-js-child-processes-everything-you-need-to-know-e69498fe970a" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.freecodecamp.org/node-js-child-processes-everything-you-need-to-know-e69498fe970a"><strong class="markup--strong markup--mixtapeEmbed-strong">Node.js Child Processes: Everything you need to know</strong><br><em class="markup--em markup--mixtapeEmbed-em">How to use spawn(), exec(), execFile(), and fork()</em>medium.freecodecamp.org</a>
                                            <a href="https://medium.freecodecamp.org/node-js-child-processes-everything-you-need-to-know-e69498fe970a" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="7248fabd9ef4945a17751645b86c2a26" data-thumbnail-img-id="1*I56pPhzO1VQw8SIsv8wYNA.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*I56pPhzO1VQw8SIsv8wYNA.png);"></a>
                                        </div>
                                        <h3 name="3d5c" id="3d5c" class="graf graf--h3 graf-after--mixtapeEmbed">The Cluster Module</h3>
                                        <p name="165b" id="165b" class="graf graf--p graf-after--h3">The cluster module can be used to enable load balancing over an environment’s multiple CPU cores. It’s based on the child process module <code class="markup--code markup--p-code">fork</code> method and it basically allows us to fork the main application process as many times as we have CPU cores. It will then take over and load balance all requests to the main process across all forked processes.</p>
                                        <p name="61df" id="61df" class="graf graf--p graf-after--p">The cluster module is Node’s helper for us to implement the cloning scalability strategy, but only on one machine. When you have a big machine with a lot of resources or when it’s easier and cheaper to add more resources to one machine rather than adding new machines, the cluster module is a great option for a really quick implementation of the cloning strategy.</p>
                                        <p name="66de" id="66de" class="graf graf--p graf-after--p">Even small machines usually have multiple cores and even if you’re not worried about the load on your Node server, you should enable the cluster module anyway to increase your server availability and fault-tolerance. It’s a simple step and when using a process manager like PM2, for example, it becomes as simple as just providing an argument to the launch command!</p>
                                        <p name="38d3" id="38d3" class="graf graf--p graf-after--p">But let me tell you how to use the cluster module natively and explain how it works.</p>
                                        <p name="3218" id="3218" class="graf graf--p graf-after--p">The structure of what the cluster module does is simple. We create a <em class="markup--em markup--p-em">master </em>process and that master process forks a number of <em class="markup--em markup--p-em">worker</em> processes and manages them. Each worker process represents an instance of the application that we want to scale. All incoming requests are handled by the master process, which is the one that decides which worker process should handle an incoming request.</p>
                                    </div>
                                    <div class="section-inner sectionLayout--outsetColumn">
                                        <figure name="8ed8" id="8ed8" class="graf graf--figure graf--layoutOutsetCenter graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 563px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*C7ICI8d7aAna_zTZvZ64MA.png" data-width="2560" data-height="1440" data-is-featured="true" data-action="zoom" data-action-value="1*C7ICI8d7aAna_zTZvZ64MA.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*C7ICI8d7aAna_zTZvZ64MA.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1000/1*C7ICI8d7aAna_zTZvZ64MA.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1000/1*C7ICI8d7aAna_zTZvZ64MA.png"></noscript>
                                                </div>
                                            </div>
                                            <figcaption class="imageCaption">Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="1fe2" id="1fe2" class="graf graf--p graf-after--figure">The master process’s job is easy because it actually just uses a <em class="markup--em markup--p-em">round-robin</em> algorithm to pick a worker process. This is enabled by default on all platforms except Windows and it can be globally modified to let the load-balancing be handled by the operation system itself.</p>
                                        <p name="c047" id="c047" class="graf graf--p graf-after--p">The round-robin algorithm distributes the load evenly across all available processes on a rotational basis. The first request is forwarded to the first worker process, the second to the next worker process in the list, and so on. When the end of the list is reached, the algorithm starts again from the beginning.</p>
                                        <p name="b0bc" id="b0bc" class="graf graf--p graf-after--p">This is one of the simplest and most used load balancing algorithms. But it’s not the only one. More featured algorithms allow assigning priorities and selecting the least loaded server or the one with the fastest response time.</p>
                                        <h4 name="46a8" id="46a8" class="graf graf--h4 graf-after--p">Load-Balancing an HTTP Server</h4>
                                        <p name="e6be" id="e6be" class="graf graf--p graf-after--h4">Let’s clone and load balance a simple HTTP server using the cluster module. Here’s the simple Node’s hello-world example server slightly modified to simulate some CPU work before responding:</p><pre name="3f56" id="3f56" class="graf graf--pre graf-after--p">// server.js</pre><pre name="7df0" id="7df0" class="graf graf--pre graf-after--pre">const http = require(&#39;http&#39;);<br>const pid = process.pid;<br><br>http.createServer((req, res) =&gt; {<br>  for (let i=0; i&lt;1e7; i++); // simulate CPU work<br>  res.end(`Handled by process ${pid}`);<br>}).listen(8080, () =&gt; {<br>  console.log(`Started process ${pid}`);<br>});</pre>
                                        <p name="0a28" id="0a28" class="graf graf--p graf-after--pre">To verify that the balancer we’re going to create is going to work, I’ve included the process <code class="markup--code markup--p-code">pid</code> in the HTTP response to identify which instance of the application is actually handling a request.</p>
                                        <p name="4388" id="4388" class="graf graf--p graf-after--p">Before we create a cluster to clone this server into multiple workers, let’s do a simple benchmark of how many requests this server can handle per second. We can use the <a href="https://httpd.apache.org/docs/2.4/programs/ab.html" data-href="https://httpd.apache.org/docs/2.4/programs/ab.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Apache benchmarking tool</a> for that. After running the simple <code class="markup--code markup--p-code">server.js</code> code above, run this <code class="markup--code markup--p-code">ab</code> command:</p><pre name="fc4b" id="fc4b" class="graf graf--pre graf-after--p">ab -c200 -t10 http://localhost:8080/</pre>
                                        <p name="60bc" id="60bc" class="graf graf--p graf-after--pre">This command will test-load the server with 200 concurrent connections for 10 seconds.</p>
                                    </div>
                                    <div class="section-inner sectionLayout--outsetColumn">
                                        <figure name="6ace" id="6ace" class="graf graf--figure graf--layoutOutsetCenter graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 563px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*w8VmzV81atlTzHn7pDXu1g.png" data-width="2560" data-height="1440" data-action="zoom" data-action-value="1*w8VmzV81atlTzHn7pDXu1g.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*w8VmzV81atlTzHn7pDXu1g.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1000/1*w8VmzV81atlTzHn7pDXu1g.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1000/1*w8VmzV81atlTzHn7pDXu1g.png"></noscript>
                                                </div>
                                            </div>
                                            <figcaption class="imageCaption">Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="f550" id="f550" class="graf graf--p graf-after--figure">On my machine, the single node server was able to handle about 51 requests per second. Of course, the results here will be different on different platforms and this is a very simplified test of performance that’s not a 100% accurate, but it will clearly show the difference that a cluster would make in a multi-core environment.</p>
                                        <p name="3d58" id="3d58" class="graf graf--p graf-after--p">Now that we have a reference benchmark, we can scale the application with the cloning strategy using the cluster module.</p>
                                        <p name="df39" id="df39" class="graf graf--p graf-after--p">On the same level as the <code class="markup--code markup--p-code">server.js</code> file above, we can create a new file (<code class="markup--code markup--p-code">cluster.js</code>) for the master process with this content (explanation follows):</p><pre name="6437" id="6437" class="graf graf--pre graf-after--p">// cluster.js</pre><pre name="1eb9" id="1eb9" class="graf graf--pre graf-after--pre">const cluster = require(&#39;cluster&#39;);<br>const os = require(&#39;os&#39;);<br><br>if (cluster.isMaster) {<br>  const cpus = os.cpus().length;<br><br>  console.log(`Forking for ${cpus} CPUs`);<br>  for (let i = 0; i&lt;cpus; i++) {<br>    cluster.fork();<br>  }<br>} else {<br>  require(&#39;./server&#39;);<br>}</pre>
                                        <p name="6472" id="6472" class="graf graf--p graf-after--pre">In <code class="markup--code markup--p-code">cluster.js</code>, we first required both the <code class="markup--code markup--p-code">cluster</code> module and the <code class="markup--code markup--p-code">os</code> module. We use the <code class="markup--code markup--p-code">os</code> module to read the number of CPU cores we can work with using <code class="markup--code markup--p-code">os.cpus()</code>.</p>
                                        <p name="b129" id="b129" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">cluster</code> module gives us the handy Boolean flag <code class="markup--code markup--p-code">isMaster</code> to determine if this <code class="markup--code markup--p-code">cluster.js</code> file is being loaded as a master process or not. The first time we execute this file, we will be executing the master process and that <code class="markup--code markup--p-code">isMaster</code> flag will be set to true. In this case, we can instruct the master process to fork our server as many times as we have CPU cores.</p>
                                        <p name="a854" id="a854" class="graf graf--p graf-after--p">Now we just read the number of CPUs we have using the <code class="markup--code markup--p-code">os</code> module, then with a for loop over that number, we call the <code class="markup--code markup--p-code">cluster.fork</code> method. The for loop will simply create as many workers as the number of CPUs in the system to take advantage of all the available processing power.</p>
                                        <p name="714f" id="714f" class="graf graf--p graf-after--p">When the <code class="markup--code markup--p-code">cluster.fork</code> line is executed from the master process, the current file, <code class="markup--code markup--p-code">cluster.js</code>, is run again, but this time in <em class="markup--em markup--p-em">worker mode</em> with the <code class="markup--code markup--p-code">isMaster</code> flag set to false. <em class="markup--em markup--p-em">There is actually another flag set to true in this case if you need to use it, which is the </em><code class="markup--code markup--p-code"><em class="markup--em markup--p-em">isWorker</em></code><em class="markup--em markup--p-em"> flag.</em></p>
                                        <p name="bc7d" id="bc7d" class="graf graf--p graf-after--p">When the application runs as a worker, it can start doing the actual work. This is where we need to define our server logic, which, for this example, we can do by requiring the <code class="markup--code markup--p-code">server.js</code> file that we have already.</p>
                                        <p name="2c73" id="2c73" class="graf graf--p graf-after--p">That’s basically it. That’s how easy it is to take advantage of all the processing power in a machine. To test the cluster, run the <code class="markup--code markup--p-code">cluster.js</code> file:</p>
                                        <figure name="8415" id="8415" class="graf graf--figure graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 542px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 77.4%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*c0S-W4GYgCGB_maJ94ZLPw.png" data-width="708" data-height="548" data-action="zoom" data-action-value="1*c0S-W4GYgCGB_maJ94ZLPw.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*c0S-W4GYgCGB_maJ94ZLPw.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/800/1*c0S-W4GYgCGB_maJ94ZLPw.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/800/1*c0S-W4GYgCGB_maJ94ZLPw.png"></noscript>
                                                </div>
                                            </div>
                                            <figcaption class="imageCaption">Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption>
                                        </figure>
                                        <p name="cf2e" id="cf2e" class="graf graf--p graf-after--figure">I have 8 cores on my machine so it started 8 processes. It’s important to understand that these are completely different Node.js processes. Each worker process here will have its own event loop and memory space.</p>
                                        <p name="d990" id="d990" class="graf graf--p graf-after--p">When we now hit the web server multiple times, the requests will start to get handled by different worker processes with different process ids. The workers will not be exactly rotated in sequence because the cluster module performs some optimizations when picking the next worker, but the load will be somehow distributed among the different worker processes.</p>
                                        <p name="f856" id="f856" class="graf graf--p graf-after--p">We can use the same <code class="markup--code markup--p-code">ab</code> command above to load-test this cluster of processes:</p>
                                    </div>
                                    <div class="section-inner sectionLayout--outsetColumn">
                                        <figure name="f851" id="f851" class="graf graf--figure graf--layoutOutsetCenter graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 563px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*5_EogHG-Egf2uAMOj9PmCA.png" data-width="2560" data-height="1440" data-action="zoom" data-action-value="1*5_EogHG-Egf2uAMOj9PmCA.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*5_EogHG-Egf2uAMOj9PmCA.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1000/1*5_EogHG-Egf2uAMOj9PmCA.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1000/1*5_EogHG-Egf2uAMOj9PmCA.png"></noscript>
                                                </div>
                                            </div>
                                            <figcaption class="imageCaption">Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="c756" id="c756" class="graf graf--p graf-after--figure">The cluster I created on my machine was able to handle 181 requests per second in comparison to the 51 requests per second that we got using a single Node process. The performance of this simple application tripled with just a few lines of code.</p>
                                        <h4 name="2d17" id="2d17" class="graf graf--h4 graf-after--p">Broadcasting Messages to All Workers</h4>
                                        <p name="5688" id="5688" class="graf graf--p graf-after--h4">Communicating between the master process and the workers is simple because under the hood the cluster module is just using the <code class="markup--code markup--p-code">child_process.fork</code> API, which means we also have communication channels available between the master process and each worker.</p>
                                        <p name="264c" id="264c" class="graf graf--p graf-after--p">Based on the <code class="markup--code markup--p-code">server.js</code>/<code class="markup--code markup--p-code">cluster.js</code> example above, we can access the list of worker objects using <code class="markup--code markup--p-code">cluster.workers</code>, which is an object that holds a reference to all workers and can be used to read information about these workers. Since we have communication channels between the master process and all workers, to broadcast a message to all them we just need a simple loop over all the workers. For example:</p><pre name="fd1a" id="fd1a" class="graf graf--pre graf-after--p">Object.values(cluster.workers).forEach(worker =&gt; {<br>  worker.send(`Hello Worker ${worker.id}`);<br>});</pre>
                                        <p name="621e" id="621e" class="graf graf--p graf-after--pre">We simply used <code class="markup--code markup--p-code">Object.values</code> to get an array of all workers from the <code class="markup--code markup--p-code">cluster.workers</code> object. Then, for each worker, we can use the <code class="markup--code markup--p-code">send</code> function to send over any value that we want.</p>
                                        <p name="ce96" id="ce96" class="graf graf--p graf-after--p">In a worker file, <code class="markup--code markup--p-code">server.js</code> in our example, to read a message received from this master process, we can register a handler for the <code class="markup--code markup--p-code">message</code> event on the global <code class="markup--code markup--p-code">process</code> object. For example:</p><pre name="44cd" id="44cd" class="graf graf--pre graf-after--p">process.on(&#39;message&#39;, msg =&gt; {<br>  console.log(`Message from master: ${msg}`);<br>});</pre>
                                        <p name="178d" id="178d" class="graf graf--p graf-after--pre">Here is what I see when I test these two additions to the cluster/server example:</p>
                                    </div>
                                    <div class="section-inner sectionLayout--outsetColumn">
                                        <figure name="b6d0" id="b6d0" class="graf graf--figure graf--layoutOutsetCenter graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 563px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*6XfoWiNKTCiDjqar7L5_xw.png" data-width="2560" data-height="1440" data-action="zoom" data-action-value="1*6XfoWiNKTCiDjqar7L5_xw.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*6XfoWiNKTCiDjqar7L5_xw.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1000/1*6XfoWiNKTCiDjqar7L5_xw.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1000/1*6XfoWiNKTCiDjqar7L5_xw.png"></noscript>
                                                </div>
                                            </div>
                                            <figcaption class="imageCaption">Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="d089" id="d089" class="graf graf--p graf-after--figure">Every worker received a message from the master process. <em class="markup--em markup--p-em">Note how the workers did not start in order.</em></p>
                                        <p name="34bc" id="34bc" class="graf graf--p graf-after--p">Let’s make this communication example a little bit more practical. Let’s say we want our server to reply with the number of users we have created in our database. We’ll create a mock function that returns the number of users we have in the database and just have it square its value every time it’s called (dream growth):</p><pre name="151d" id="151d" class="graf graf--pre graf-after--p">// **** Mock DB Call<br>const numberOfUsersInDB = function() {<br>  this.count = this.count || 5;<br>  this.count = this.count * this.count;<br>  return this.count;<br>}<br>// ****</pre>
                                        <p name="82b0" id="82b0" class="graf graf--p graf-after--pre">Every time <code class="markup--code markup--p-code">numberOfUsersInDB</code> is called, we’ll assume that a database connection has been made. What we want to do here — to avoid multiple DB requests — is to cache this call for a certain period of time, such as 10 seconds. However, we still don’t want the 8 forked workers to do their own DB requests and end up with 8 DB requests every 10 seconds. We can have the master process do just one request and tell all of the 8 workers about the new value for the user count using the communication interface.</p>
                                        <p name="6113" id="6113" class="graf graf--p graf-after--p">In the master process mode, we can, for example, use the same loop to broadcast the users count value to all workers:</p><pre name="87b6" id="87b6" class="graf graf--pre graf-after--p">// Right after the fork loop within the isMaster=true block</pre><pre name="8cc8" id="8cc8" class="graf graf--pre graf-after--pre">const updateWorkers = () =&gt; {<br>  const usersCount = numberOfUsersInDB();<br>  Object.values(cluster.workers).forEach(worker =&gt; {<br>    worker.send({ usersCount });<br>  });<br>};<br><br>updateWorkers();<br>setInterval(updateWorkers, 10000);</pre>
                                        <p name="796d" id="796d" class="graf graf--p graf-after--pre">Here we’re invoking <code class="markup--code markup--p-code">updateWorkers</code> for the first time and then invoking it every 10 seconds using a <code class="markup--code markup--p-code">setInterval</code>. This way, every 10 seconds, all workers will receive the new user count value over the process communication channel and only one database connection will be made.</p>
                                        <p name="c5b0" id="c5b0" class="graf graf--p graf-after--p">In the server code, we can use the <code class="markup--code markup--p-code">usersCount</code> value using the same <code class="markup--code markup--p-code">message</code> event handler. We can simply cache that value with a module global variable and use it anywhere we want.</p>
                                        <p name="3a7a" id="3a7a" class="graf graf--p graf-after--p">For example:</p><pre name="88cf" id="88cf" class="graf graf--pre graf-after--p">const http = require(&#39;http&#39;);<br>const pid = process.pid;<br><br><strong class="markup--strong markup--pre-strong">let usersCount;<br></strong><br>http.createServer((req, res) =&gt; {<br>  for (let i=0; i&lt;1e7; i++); // simulate CPU work<br>  res.write(`Handled by process ${pid}\n`);<br>  <strong class="markup--strong markup--pre-strong">res.end(`Users: ${usersCount}`);</strong><br>}).listen(8080, () =&gt; {<br>  console.log(`Started process ${pid}`);<br>});<br><br>process.on(&#39;message&#39;, msg =&gt; {<br>  <strong class="markup--strong markup--pre-strong">usersCount = msg.usersCount;</strong><br>});</pre>
                                        <p name="ecbd" id="ecbd" class="graf graf--p graf-after--pre">The above code makes the worker web server respond with the cached <code class="markup--code markup--p-code">usersCount</code><strong class="markup--strong markup--p-strong"> </strong>value. If you test the cluster code now, during the first 10 seconds you’ll get “25” as the users count from all workers (and only one DB request would be made). Then after another 10 seconds, all workers would start reporting the new user count, 625 (and only one other DB request would be made).</p>
                                        <p name="4b55" id="4b55" class="graf graf--p graf-after--p">This is all possible thanks to the communication channels between the master process and all workers.</p>
                                        <h4 name="5fb9" id="5fb9" class="graf graf--h4 graf-after--p">Increasing Server Availability</h4>
                                        <p name="6ccf" id="6ccf" class="graf graf--p graf-after--h4">One of the problems in running a single instance of a Node application is that when that instance crashes, it has to be restarted. This means some downtime between these two actions, even if the process was automated as it should be.</p>
                                        <p name="ca50" id="ca50" class="graf graf--p graf-after--p">This also applies to the case when the server has to be restarted to deploy new code. With one instance, there will be downtime which affects the availability of the system.</p>
                                        <p name="79bd" id="79bd" class="graf graf--p graf-after--p">When we have multiple instances, the availability of the system can be easily increased with just a few extra lines of code.</p>
                                        <p name="67ad" id="67ad" class="graf graf--p graf-after--p">To simulate a random crash in the server process, we can simply do a <code class="markup--code markup--p-code">process.exit</code> call inside a timer that fires after a random amount of time:</p><pre name="7b98" id="7b98" class="graf graf--pre graf-after--p">// In server.js</pre><pre name="8621" id="8621" class="graf graf--pre graf-after--pre">setTimeout(() =&gt; {<br>  process.exit(1) // death by random timeout<br>}, Math.random() * 10000);</pre>
                                        <p name="9a63" id="9a63" class="graf graf--p graf-after--pre">When a worker process exits like this, the master process will be notified using the <code class="markup--code markup--p-code">exit</code> event on the <code class="markup--code markup--p-code">cluster</code> model object. We can register a handler for that event and just fork a new worker process when any worker process exits.</p>
                                        <p name="8e0d" id="8e0d" class="graf graf--p graf-after--p">For example:</p><pre name="e242" id="e242" class="graf graf--pre graf-after--p">// Right after the fork loop within the isMaster=true block</pre><pre name="37c1" id="37c1" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">cluster</strong>.on(&#39;<strong class="markup--strong markup--pre-strong">exit</strong>&#39;, (worker, code, signal) =&gt; {<br>  if (code !== 0 &amp;&amp; !worker.exitedAfterDisconnect) {<br>    console.log(`Worker ${worker.id} crashed. ` +<br>                &#39;Starting a new worker...&#39;);<br>    <strong class="markup--strong markup--pre-strong">cluster.fork();</strong><br>  }<br>});</pre>
                                        <p name="d39b" id="d39b" class="graf graf--p graf-after--pre">It’s good to add the if condition above to make sure the worker process actually crashed and was not manually disconnected or killed by the master process itself. For example, the master process might decide that we are using too many resources based on the load patterns it sees and it will need to kill a few workers in that case. To do so, we can use the <code class="markup--code markup--p-code">disconnect</code> methods on any worker and, in that case, the <code class="markup--code markup--p-code">exitedAfterDisconnect</code> flag will be set to true. The if statement above will guard to not fork a new worker for that case.</p>
                                        <p name="1b6b" id="1b6b" class="graf graf--p graf-after--p">If we run the cluster with the handler above (and the random crash in <code class="markup--code markup--p-code">server.js</code>), after a random number of seconds, workers will start to crash and the master process will immediately fork new workers to increase the availability of the system. You can actually measure the availability using the same <code class="markup--code markup--p-code">ab</code> command and see how many requests the server will not be able to handle overall (because some of the unlucky requests will have to face the crash case and that’s hard to avoid.)</p>
                                        <p name="0013" id="0013" class="graf graf--p graf-after--p">When I tested the code, only 17 requests failed out of over 1800 in the 10-second testing interval with 200 concurrent requests.</p>
                                    </div>
                                    <div class="section-inner sectionLayout--outsetColumn">
                                        <figure name="e368" id="e368" class="graf graf--figure graf--layoutOutsetCenter graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 563px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*B72o6QhsyiNnEQU5Wx20RQ.png" data-width="2560" data-height="1440" data-action="zoom" data-action-value="1*B72o6QhsyiNnEQU5Wx20RQ.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*B72o6QhsyiNnEQU5Wx20RQ.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1000/1*B72o6QhsyiNnEQU5Wx20RQ.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1000/1*B72o6QhsyiNnEQU5Wx20RQ.png"></noscript>
                                                </div>
                                            </div>
                                            <figcaption class="imageCaption">Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="bbab" id="bbab" class="graf graf--p graf-after--figure">That’s over 99% availability. By just adding a few lines of code, we now don’t have to worry about process crashes anymore. The master guardian will keep an eye on those processes for us.</p>
                                        <h4 name="4505" id="4505" class="graf graf--h4 graf-after--p">Zero-downtime Restarts</h4>
                                        <p name="17b3" id="17b3" class="graf graf--p graf-after--h4">What about the case when we want to restart all worker processes when, for example, we need to deploy new code?</p>
                                        <p name="1fde" id="1fde" class="graf graf--p graf-after--p">We have multiple instances running, so instead of restarting them together, we can simply restart them one at a time to allow other workers to continue to serve requests while one worker is being restarted.</p>
                                        <p name="5489" id="5489" class="graf graf--p graf-after--p">Implementing this with the cluster module is easy. Since we don’t want to restart the master process once it’s up, we need a way to send this master process a command to instruct it to start restarting its workers. This is easy on Linux systems because we can simply listen to a process signal like <code class="markup--code markup--p-code">SIGUSR2</code>, which we can trigger by using the <code class="markup--code markup--p-code">kill</code> command on the process id and passing that signal:</p><pre name="a1d1" id="a1d1" class="graf graf--pre graf-after--p">// In Node<br>process.on(&#39;SIGUSR2&#39;, () =&gt; { ... });</pre><pre name="7fbc" id="7fbc" class="graf graf--pre graf-after--pre">// To trigger that<br>$ kill -SIGUSR2 PID</pre>
                                        <p name="4024" id="4024" class="graf graf--p graf-after--pre">This way, the master process will not be killed and we have a way to instruct it to start doing something. <code class="markup--code markup--p-code">SIGUSR2</code> is a proper signal to use here because this will be a user command. If you’re wondering why not <code class="markup--code markup--p-code">SIGUSR1</code>, it’s because Node uses that for its debugger and you want to avoid any conflicts.</p>
                                        <p name="0740" id="0740" class="graf graf--p graf-after--p">Unfortunately, on Windows, these process signal are not supported and we would have to find another way to command the master process to do something. There are some alternatives. We can, for example, use standard input or socket input. Or we can monitor the existence of a <code class="markup--code markup--p-code">process.pid</code> file and watch that for a remove event. But to keep this example simple, we’ll just assume this server is running on a Linux platform.</p>
                                        <p name="7990" id="7990" class="graf graf--p graf-after--p">Node works very well on Windows, but I think it’s a much safer option to host production Node applications on a Linux platform. This is not just because of Node itself, but many other production tools that are much more stable on Linux. This is my personal opinion and feel free to completely ignore it.</p>
                                        <p name="619d" id="619d" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">By the way, on recent versions of Windows, you can actually use a Linux subsystem and it works very well. I’ve tested it myself and it was nothing short of impressive. If you’re developing a Node applications on Windows, check out </em><a href="https://msdn.microsoft.com/en-us/commandline/wsl/about" data-href="https://msdn.microsoft.com/en-us/commandline/wsl/about" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">Bash on Windows</em></a><em class="markup--em markup--p-em"> and give it a try.</em></p>
                                        <p name="61f6" id="61f6" class="graf graf--p graf-after--p">In our example, when the master process receives the <code class="markup--code markup--p-code">SIGUSR2</code> signal, that means it’s time for it to restart its workers, but we want to do that one worker at a time. This simply means the master process should only restart the next worker when it’s done restarting the current one.</p>
                                        <p name="b02e" id="b02e" class="graf graf--p graf-after--p">To begin this task, we need to get a reference to all current workers using the <code class="markup--code markup--p-code">cluster.workers</code> object and we can simply just store the workers in an array:</p><pre name="9804" id="9804" class="graf graf--pre graf-after--p">const workers = Object.values(cluster.workers);</pre>
                                        <p name="375a" id="375a" class="graf graf--p graf-after--pre">Then, we can create a <code class="markup--code markup--p-code">restartWorker</code> function that receives the index of the worker to be restarted. This way we can do the restarting in sequence by having the function call itself when it’s ready for the next worker. Here’s an example <code class="markup--code markup--p-code">restartWorker</code> function that we can use (explanation follows):</p><pre name="6dcb" id="6dcb" class="graf graf--pre graf-after--p">const restartWorker = (workerIndex) =&gt; {<br>  const worker = workers[workerIndex];<br>  if (!worker) return;<br><br>  worker.on(&#39;exit&#39;, () =&gt; {<br>    if (!worker.exitedAfterDisconnect) return;<br>    console.log(`Exited process ${worker.process.pid}`);<br>    <br>    cluster.fork().on(&#39;listening&#39;, () =&gt; {<br>      restartWorker(workerIndex + 1);<br>    });<br>  });<br><br>  worker.disconnect();<br>};<br><br>restartWorker(0);</pre>
                                        <p name="a35f" id="a35f" class="graf graf--p graf-after--pre">Inside the <code class="markup--code markup--p-code">restartWorker</code> function, we got a reference to the worker to be restarted and since we will be calling this function recursively to form a sequence, we need a stop condition. When we no longer have a worker to restart, we can just return. We then basically want to disconnect this worker (using <code class="markup--code markup--p-code">worker.disconnect</code>), but before restarting the next worker, we need to fork a new worker to replace this current one that we’re disconnecting.</p>
                                        <p name="41f8" id="41f8" class="graf graf--p graf-after--p">We can use the <code class="markup--code markup--p-code">exit</code> event on the worker itself to fork a new worker when the current one exists, but we have to make sure that the exit action was actually triggered after a normal disconnect call. We can use the <code class="markup--code markup--p-code">exitedAfetrDisconnect</code> flag. If this flag is not true, the exit was caused by something else other than our disconnect call and in that case, we should just return and do nothing. But if the flag is set to true, we can go ahead and fork a new worker to replace the one that we’re disconnecting.</p>
                                        <p name="dc08" id="dc08" class="graf graf--p graf-after--p">When this new forked worker is ready, we can restart the next one. However, remember that the fork process is not synchronous, so we can’t just restart the next worker after the fork call. Instead, we can monitor the <code class="markup--code markup--p-code">listening</code> event on the newly forked worker, which tells us that this worker is connected and ready. When we get this event, we can safely restart the next worker in sequence.</p>
                                        <p name="6f65" id="6f65" class="graf graf--p graf-after--p">That’s all we need for a zero-downtime restart. To test it, you’ll need to read the master process id to be sent to the <code class="markup--code markup--p-code">SIGUSR2 </code>signal:</p><pre name="cd99" id="cd99" class="graf graf--pre graf-after--p">console.log(`Master PID: ${process.pid}`);</pre>
                                        <p name="6d1e" id="6d1e" class="graf graf--p graf-after--pre">Start the cluster, copy the master process id, and then restart the cluster using the <code class="markup--code markup--p-code">kill -SIGUSR2 PID</code> command. You can also run the same <code class="markup--code markup--p-code">ab</code> command while restarting the cluster to see the effect that this restart process will have on availability. Spoiler alert, you should get ZERO failed requests:</p>
                                    </div>
                                    <div class="section-inner sectionLayout--outsetColumn">
                                        <figure name="8cef" id="8cef" class="graf graf--figure graf--layoutOutsetCenter graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 563px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*NjG0e2ARIDQiYSHWNvdNPQ.png" data-width="2560" data-height="1440" data-action="zoom" data-action-value="1*NjG0e2ARIDQiYSHWNvdNPQ.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*NjG0e2ARIDQiYSHWNvdNPQ.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1000/1*NjG0e2ARIDQiYSHWNvdNPQ.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1000/1*NjG0e2ARIDQiYSHWNvdNPQ.png"></noscript>
                                                </div>
                                            </div>
                                            <figcaption class="imageCaption">Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="3cd7" id="3cd7" class="graf graf--p graf-after--figure">Process monitors like PM2, which I personally use in production, make all the tasks we went through so far extremely easy and give a lot more features to monitor the health of a Node.js application. For example, with PM2, to launch a cluster for any app, all you need to do is use the <code class="markup--code markup--p-code">-i</code> argument:</p><pre name="e484" id="e484" class="graf graf--pre graf-after--p">pm2 start server.js -i max</pre>
                                        <p name="b50b" id="b50b" class="graf graf--p graf-after--pre">And to do a zero downtime restart you just issue this magic command:</p><pre name="1a39" id="1a39" class="graf graf--pre graf-after--p">pm2 reload all</pre>
                                        <p name="2aef" id="2aef" class="graf graf--p graf-after--pre">However, I find it helpful to first understand what actually will happen under the hood when you use these commands.</p>
                                        <h4 name="a6b9" id="a6b9" class="graf graf--h4 graf-after--p">Shared State and Sticky Load Balancing</h4>
                                        <p name="648a" id="648a" class="graf graf--p graf-after--h4">Good things always come with a cost. When we load balance a Node application, we lose some features that are only suitable for a single process. This problem is somehow similar to what’s known in other languages as thread safety, which is about sharing data between threads. In our case, it’s sharing data between worker processes.</p>
                                        <p name="f6ce" id="f6ce" class="graf graf--p graf-after--p">For example, with a cluster setup, we can no longer cache things in memory because every worker process will have its own memory space. If we cache something in one worker’s memory, other workers will not have access to it.</p>
                                        <p name="b317" id="b317" class="graf graf--p graf-after--p">If we need to cache things with a cluster setup, we have to use a separate entity and read/write to that entity’s API from all workers. This entity can be a database server or if you want to use in-memory cache you can use a server like Redis or create a dedicated Node process with a read/write API for all other workers to communicate with.</p>
                                    </div>
                                    <div class="section-inner sectionLayout--outsetColumn">
                                        <figure name="9d44" id="9d44" class="graf graf--figure graf--layoutOutsetCenter graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 563px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*dIR_CAkmtPFgtaGTOKBFkA.png" data-width="2560" data-height="1440" data-action="zoom" data-action-value="1*dIR_CAkmtPFgtaGTOKBFkA.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*dIR_CAkmtPFgtaGTOKBFkA.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1000/1*dIR_CAkmtPFgtaGTOKBFkA.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1000/1*dIR_CAkmtPFgtaGTOKBFkA.png"></noscript>
                                                </div>
                                            </div>
                                            <figcaption class="imageCaption">Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="b90e" id="b90e" class="graf graf--p graf-after--figure">Don’t look at this as a disadvantage though, because using a separate entity for your application caching needs is part of <em class="markup--em markup--p-em">decomposing</em> your app for scalability. You should probably be doing that even if you’re running on a single core machine.</p>
                                        <p name="31d9" id="31d9" class="graf graf--p graf-after--p">Other than caching, when we’re running on a cluster, stateful communication in general becomes a problem. Since the communication is not guaranteed to be with the same worker, creating a stateful channel on any one worker is not an option.</p>
                                        <p name="c880" id="c880" class="graf graf--p graf-after--p">The most common example for this is authenticating users.</p>
                                    </div>
                                    <div class="section-inner sectionLayout--outsetColumn">
                                        <figure name="ced6" id="ced6" class="graf graf--figure graf--layoutOutsetCenter graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 563px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*jKAmrLPMer6_kmpIjyGzxA.png" data-width="2560" data-height="1440" data-action="zoom" data-action-value="1*jKAmrLPMer6_kmpIjyGzxA.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*jKAmrLPMer6_kmpIjyGzxA.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1000/1*jKAmrLPMer6_kmpIjyGzxA.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1000/1*jKAmrLPMer6_kmpIjyGzxA.png"></noscript>
                                                </div>
                                            </div>
                                            <figcaption class="imageCaption">Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="f279" id="f279" class="graf graf--p graf-after--figure">With a cluster, the request for authentication comes to the master balancer process, which gets sent to a worker, assuming that to be A in this example.</p>
                                    </div>
                                    <div class="section-inner sectionLayout--outsetColumn">
                                        <figure name="46f0" id="46f0" class="graf graf--figure graf--layoutOutsetCenter graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 563px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*dNUlcuEXPkk44A63ct0s0g.png" data-width="2560" data-height="1440" data-action="zoom" data-action-value="1*dNUlcuEXPkk44A63ct0s0g.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*dNUlcuEXPkk44A63ct0s0g.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1000/1*dNUlcuEXPkk44A63ct0s0g.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1000/1*dNUlcuEXPkk44A63ct0s0g.png"></noscript>
                                                </div>
                                            </div>
                                            <figcaption class="imageCaption">Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="c652" id="c652" class="graf graf--p graf-after--figure">Worker A now recognizes the state of this user. However, when the same user makes another request, the load balancer will eventually send them to other workers, which do not have them as authenticated. Keeping a reference to an authenticated user session in one instance memory is not going to work anymore.</p>
                                        <p name="469f" id="469f" class="graf graf--p graf-after--p">This problem can be solved in many ways. We can simply share the state across the many workers we have by storing these sessions’ information in a shared database or a Redis node. However, applying this strategy requires some code changes, which is not always an option.</p>
                                        <p name="dc31" id="dc31" class="graf graf--p graf-after--p">If you can’t do the code modifications needed to make a shared storage of sessions here, there is a less invasive but not as efficient strategy. You can use what’s known as Sticky Load Balancing. This is much simpler to implement as many load balancers support this strategy out of the box. The idea is simple. When a user authenticates with a worker instance, we keep a record of that relation on the load balancer level.</p>
                                    </div>
                                    <div class="section-inner sectionLayout--outsetColumn">
                                        <figure name="1191" id="1191" class="graf graf--figure graf--layoutOutsetCenter graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 563px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*P4LNRLkZ9n_p8OKtmRM9LA.png" data-width="2560" data-height="1440" data-action="zoom" data-action-value="1*P4LNRLkZ9n_p8OKtmRM9LA.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*P4LNRLkZ9n_p8OKtmRM9LA.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1000/1*P4LNRLkZ9n_p8OKtmRM9LA.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1000/1*P4LNRLkZ9n_p8OKtmRM9LA.png"></noscript>
                                                </div>
                                            </div>
                                            <figcaption class="imageCaption">Screenshot captured from my Pluralsight course — Advanced Node.js</figcaption>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="720a" id="720a" class="graf graf--p graf-after--figure">Then, when the same user sends a new request, we do a lookup in this record to figure out which server has their session authenticated and keep sending them to that server instead of the normal distributed behavior. This way, the code on the server side does not have to be changed, but we don’t really get the benefit of load balancing for authenticated users here so only use sticky load balancing if you have no other option.</p>
                                        <p name="376f" id="376f" class="graf graf--p graf-after--p graf--trailing">The cluster module actually does not support sticky load balancing, but a few other load balancers can be configured to do sticky load balancing by default.</p>
                                    </div>
                                </div>
                            </section>
                            <section name="33f7" class="section section--body section--last">
                                <div class="section-divider">
                                    <hr class="section-divider">
                                </div>
                                <div class="section-content">
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="12c2" id="12c2" class="graf graf--p graf--leading">Thanks for reading. If you found this article helpful, please click the💚 below. Follow me for more articles on Node.js and JavaScript.</p>
                                        <p name="3a83" id="3a83" class="graf graf--p graf-after--p">I create <strong class="markup--strong markup--p-strong">online courses</strong> for <a href="https://app.pluralsight.com/profile/author/samer-buna" data-href="https://app.pluralsight.com/profile/author/samer-buna" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Pluralsight</a> and <a href="https://www.lynda.com/Samer-Buna/7060467-1.html" data-href="https://www.lynda.com/Samer-Buna/7060467-1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Lynda</a>. My most recent courses are <a href="https://www.pluralsight.com/courses/reactjs-advanced" data-href="https://www.pluralsight.com/courses/reactjs-advanced" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Advanced React.js</a>, <a href="https://www.pluralsight.com/courses/nodejs-advanced" data-href="https://www.pluralsight.com/courses/nodejs-advanced" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Advanced Node.js</a>, and <a href="https://www.lynda.com/Express-js-tutorials/Learning-Full-Stack-JavaScript-Development-MongoDB-Node-React/533304-2.html" data-href="https://www.lynda.com/Express-js-tutorials/Learning-Full-Stack-JavaScript-Development-MongoDB-Node-React/533304-2.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Learning Full-stack JavaScript</a>.</p>
                                        <p name="9bac" id="9bac" class="graf graf--p graf-after--p graf--trailing">I also do <strong class="markup--strong markup--p-strong">online and onsite training</strong> for groups covering beginner to advanced levels in JavaScript, Node.js, React.js, and GraphQL. <a href="mailto:samer@jscomplete.com" data-href="mailto:samer@jscomplete.com" class="markup--anchor markup--p-anchor" target="_blank">Drop me a line</a> if you’re looking for a trainer. If you have any questions about this article or any other article I wrote, find me on <a href="https://slack.jscomplete.com/" data-href="https://slack.jscomplete.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this <strong class="markup--strong markup--p-strong">slack</strong> account</a> (you can invite yourself) and ask in the #questions room.</p>
                                    </div>
                                </div>
                            </section>
                        </div>
