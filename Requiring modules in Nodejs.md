 <div class="postArticle-content js-postField js-notesSource js-trackedPost" data-post-id="e7fbd119be8" data-source="post_page" data-collection-id="336d898217ee" data-tracking-context="postPage">
                            <section name="44b4" class="section section--body section--first">
                                <div class="section-divider">
                                    <hr class="section-divider">
                                </div>
                                <div class="section-content">
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <h1 name="5563" id="5563" class="graf graf--h3 graf--leading graf--title">Requiring modules in Node.js: Everything you need to know</h1></div>
                                    <div class="section-inner sectionLayout--fullWidth">
                                        <figure name="356e" id="356e" class="graf graf--figure graf--layoutFillWidth graf-after--h3">
                                            <div class="aspectRatioPlaceholder is-locked">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 36.1%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*AL0-iuggGnBLSvSVvt0Xzw.png" data-width="1794" data-height="648"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*AL0-iuggGnBLSvSVvt0Xzw.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/2000/1*AL0-iuggGnBLSvSVvt0Xzw.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/2000/1*AL0-iuggGnBLSvSVvt0Xzw.png"></noscript>
                                                </div>
                                            </div>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="a0c3" id="a0c3" class="graf graf--p graf-after--figure">Node uses two core modules for managing module dependencies:</p>
                                        <ul class="postList">
                                            <li name="e97d" id="e97d" class="graf graf--li graf-after--p">The <code class="markup--code markup--li-code">require</code> module, which appears to be available on the global scope — no need to <code class="markup--code markup--li-code">require(&#39;require&#39;)</code>.</li>
                                            <li name="f487" id="f487" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">module</code> module, which also appears to be available on the global scope — no need to <code class="markup--code markup--li-code">require(&#39;module&#39;)</code>.</li>
                                        </ul>
                                        <p name="f56c" id="f56c" class="graf graf--p graf-after--li">You can think of the <code class="markup--code markup--p-code">require</code> module as the command and the <code class="markup--code markup--p-code">module</code> module as the organizer of all required modules.</p>
                                        <p name="2690" id="2690" class="graf graf--p graf-after--p">Requiring a module in Node isn’t that complicated of a concept.</p><pre name="e0b7" id="e0b7" class="graf graf--pre graf-after--p">const config = require(&#39;/path/to/file&#39;);</pre>
                                        <p name="bf94" id="bf94" class="graf graf--p graf-after--pre">The main object exported by the <code class="markup--code markup--p-code">require</code> module is a function (as used in the above example). When Node invokes that <code class="markup--code markup--p-code">require()</code> function with a local file path as the function’s only argument, Node goes through the following sequence of steps:</p>
                                        <ul class="postList">
                                            <li name="b785" id="b785" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Resolving</strong>: To find the absolute path of the file.</li>
                                            <li name="b893" id="b893" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Loading</strong>: To determine the type of the file content.</li>
                                            <li name="7620" id="7620" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Wrapping</strong>: To give the file its private scope. This is what makes both the <code class="markup--code markup--li-code">require</code> and <code class="markup--code markup--li-code">module</code> objects local to every file we require.</li>
                                            <li name="27bf" id="27bf" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Evaluating</strong>: This is what the VM eventually does with the loaded code.</li>
                                            <li name="b981" id="b981" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Caching</strong>: So that when we require this file again, we don’t go over all the steps another time.</li>
                                        </ul>
                                        <p name="93be" id="93be" class="graf graf--p graf-after--li">In this article, I’ll attempt to explain with examples these different stages and how they affect the way we write modules in Node.</p>
                                        <p name="8e0c" id="8e0c" class="graf graf--p graf-after--p">Let me first create a directory to host all the examples using my terminal:</p><pre name="e539" id="e539" class="graf graf--pre graf-after--p">mkdir ~/learn-node &amp;&amp; cd ~/learn-node</pre>
                                        <p name="3197" id="3197" class="graf graf--p graf-after--pre">All the commands in the rest of this article will be run from within <code class="markup--code markup--p-code">~/learn-node</code>.</p>
                                        <h4 name="7387" id="7387" class="graf graf--h4 graf-after--p">Resolving a local path</h4>
                                        <p name="c192" id="c192" class="graf graf--p graf-after--h4">Let me introduce you to the <code class="markup--code markup--p-code">module</code> object. You can check it out in a simple REPL session:</p><pre name="29d9" id="29d9" class="graf graf--pre graf-after--p">~/learn-node $ node<br>&gt; module<br>Module {<br>  id: &#39;&lt;repl&gt;&#39;,<br>  exports: {},<br>  parent: undefined,<br>  filename: null,<br>  loaded: false,<br>  children: [],<br>  paths: [ ... ] }</pre>
                                        <p name="8001" id="8001" class="graf graf--p graf-after--pre">Every module object gets an <code class="markup--code markup--p-code">id</code> property to identify it. This <code class="markup--code markup--p-code">id</code> is usually the full path to the file, but in a REPL session it’s simply <code class="markup--code markup--p-code">&lt;repl&gt;.</code></p>
                                        <p name="862b" id="862b" class="graf graf--p graf-after--p">Node modules have a one-to-one relation with files on the file-system. We require a module by loading the content of a file into memory.</p>
                                        <p name="cadb" id="cadb" class="graf graf--p graf-after--p">However, since Node allows many ways to require a file (for example, with a relative path or a pre-configured path), before we can load the content of a file into the memory we need to find the absolute location of that file.</p>
                                        <p name="c53e" id="c53e" class="graf graf--p graf-after--p">When we require a <code class="markup--code markup--p-code">&#39;find-me&#39;</code> module, without specifying a path:</p><pre name="5d8c" id="5d8c" class="graf graf--pre graf-after--p">require(&#39;find-me&#39;);</pre>
                                        <p name="506e" id="506e" class="graf graf--p graf-after--pre">Node will look for <code class="markup--code markup--p-code">find-me.js</code> in all the paths specified by <code class="markup--code markup--p-code">module.paths</code> — in order.</p><pre name="e73b" id="e73b" class="graf graf--pre graf-after--p">~/learn-node $ node<br>&gt; module.paths<br>[ &#39;/Users/samer/learn-node/repl/node_modules&#39;,<br>  &#39;/Users/samer/learn-node/node_modules&#39;,<br>  &#39;/Users/samer/node_modules&#39;,<br>  &#39;/Users/node_modules&#39;,<br>  &#39;/node_modules&#39;,<br>  &#39;/Users/samer/.node_modules&#39;,<br>  &#39;/Users/samer/.node_libraries&#39;,<br>  &#39;/usr/local/Cellar/node/7.7.1/lib/node&#39; ]</pre>
                                        <p name="c7b1" id="c7b1" class="graf graf--p graf-after--pre">The paths list is basically a list of node_modules directories under every directory from the current directory to the root directory. It also includes a few legacy directories whose use is not recommended.</p>
                                        <p name="2e11" id="2e11" class="graf graf--p graf-after--p">If Node can’t find <code class="markup--code markup--p-code">find-me.js</code> in any of these paths, it will throw a “cannot find module error.”</p><pre name="03ea" id="03ea" class="graf graf--pre graf-after--p">~/learn-node $ node<br>&gt; require(&#39;find-me&#39;)<br>Error: Cannot find module &#39;find-me&#39;<br>    at Function.Module._resolveFilename (module.js:470:15)<br>    at Function.Module._load (module.js:418:25)<br>    at Module.require (module.js:498:17)<br>    at require (internal/module.js:20:19)<br>    at repl:1:1<br>    at ContextifyScript.Script.runInThisContext (vm.js:23:33)<br>    at REPLServer.defaultEval (repl.js:336:29)<br>    at bound (domain.js:280:14)<br>    at REPLServer.runBound [as eval] (domain.js:293:12)<br>    at REPLServer.onLine (repl.js:533:10)</pre>
                                        <p name="cd8d" id="cd8d" class="graf graf--p graf-after--pre">If you now create a local <code class="markup--code markup--p-code">node_modules</code> directory and put a <code class="markup--code markup--p-code">find-me.js</code> in there, the <code class="markup--code markup--p-code">require(&#39;find-me&#39;)</code> line will find it.</p><pre name="cf94" id="cf94" class="graf graf--pre graf-after--p">~/learn-node $ mkdir node_modules </pre><pre name="3302" id="3302" class="graf graf--pre graf-after--pre">~/learn-node $ echo &quot;console.log(&#39;I am not lost&#39;);&quot; &gt; node_modules/find-me.js</pre><pre name="ae04" id="ae04" class="graf graf--pre graf-after--pre">~/learn-node $ node<br>&gt; require(&#39;find-me&#39;);<br>I am not lost<br>{}<br>&gt;</pre>
                                        <p name="6199" id="6199" class="graf graf--p graf-after--pre">If another <code class="markup--code markup--p-code">find-me.js</code> file existed in any of the other paths, for example, if we have a <code class="markup--code markup--p-code">node_modules</code> directory under the home directory and we have a different <code class="markup--code markup--p-code">find-me.js</code> file in there:</p><pre name="8c30" id="8c30" class="graf graf--pre graf-after--p">$ mkdir ~/node_modules<br>$ echo &quot;console.log(&#39;I am the root of all problems&#39;);&quot; &gt; ~/node_modules/find-me.js</pre>
                                        <p name="9d1c" id="9d1c" class="graf graf--p graf-after--pre">When we <code class="markup--code markup--p-code">require(&#39;find-me&#39;)</code> from within the <code class="markup--code markup--p-code">learn-node</code> directory — which has its own <code class="markup--code markup--p-code">node_modules/find-me.js</code>, the <code class="markup--code markup--p-code">find-me.js</code> file under the home directory will not be loaded at all:</p><pre name="c906" id="c906" class="graf graf--pre graf-after--p">~/learn-node $ node<br>&gt; require(&#39;find-me&#39;)<br>I am not lost<br>{}<br>&gt;</pre>
                                        <p name="a692" id="a692" class="graf graf--p graf-after--pre">If we remove the local <code class="markup--code markup--p-code">node_modules</code> directory under <code class="markup--code markup--p-code">~/learn-node</code> and try to require <code class="markup--code markup--p-code">find-me</code> one more time, the file under the home’s <code class="markup--code markup--p-code">node_modules</code> directory would be used:</p><pre name="dbf4" id="dbf4" class="graf graf--pre graf-after--p">~/learn-node $ rm -r node_modules/</pre><pre name="3704" id="3704" class="graf graf--pre graf-after--pre">~/learn-node $ node<br>&gt; require(&#39;find-me&#39;)<br>I am the root of all problems<br>{}<br>&gt;</pre>
                                        <h4 name="21dd" id="21dd" class="graf graf--h4 graf-after--pre">Requiring a folder</h4>
                                        <p name="5243" id="5243" class="graf graf--p graf-after--h4">Modules don’t have to be files. We can also create a <code class="markup--code markup--p-code">find-me</code> folder under <code class="markup--code markup--p-code">node_modules</code> and place an <code class="markup--code markup--p-code">index.js</code> file in there. The same <code class="markup--code markup--p-code">require(&#39;find-me&#39;)</code> line will use that folder’s <code class="markup--code markup--p-code">index.js</code> file:</p><pre name="6658" id="6658" class="graf graf--pre graf-after--p">~/learn-node $ mkdir -p node_modules/find-me</pre><pre name="a9d7" id="a9d7" class="graf graf--pre graf-after--pre">~/learn-node $ echo &quot;console.log(&#39;Found again.&#39;);&quot; &gt; node_modules/find-me/index.js</pre><pre name="afad" id="afad" class="graf graf--pre graf-after--pre">~/learn-node $ node<br>&gt; require(&#39;find-me&#39;);<br>Found again.<br>{}<br>&gt;</pre>
                                        <p name="3b87" id="3b87" class="graf graf--p graf-after--pre">Note how it ignored the home directory’s <code class="markup--code markup--p-code">node_modules</code> path again since we have a local one now.</p>
                                        <p name="ffba" id="ffba" class="graf graf--p graf-after--p">An <code class="markup--code markup--p-code">index.js</code> file will be used by default when we require a folder, but we can control what file name to start with under the folder using the <code class="markup--code markup--p-code">main</code> property in <code class="markup--code markup--p-code">package.json</code>. For example, to make the <code class="markup--code markup--p-code">require(&#39;find-me&#39;)</code> line resolve to a different file under the <code class="markup--code markup--p-code">find-me</code> folder, all we need to do is add a <code class="markup--code markup--p-code">package.json</code> file in there and specify which file should be used to resolve this folder:</p><pre name="f1b0" id="f1b0" class="graf graf--pre graf-after--p">~/learn-node $ echo &quot;console.log(&#39;I rule&#39;);&quot; &gt; node_modules/find-me/start.js</pre><pre name="f59b" id="f59b" class="graf graf--pre graf-after--pre">~/learn-node $ echo &#39;{ &quot;name&quot;: &quot;find-me-folder&quot;, &quot;main&quot;: &quot;start.js&quot; }&#39; &gt; node_modules/find-me/package.json</pre><pre name="624a" id="624a" class="graf graf--pre graf-after--pre">~/learn-node $ node<br>&gt; require(&#39;find-me&#39;);<br>I rule<br>{}<br>&gt;</pre>
                                        <h4 name="08bc" id="08bc" class="graf graf--h4 graf-after--pre">require.resolve</h4>
                                        <p name="2e09" id="2e09" class="graf graf--p graf-after--h4">If you want to only resolve the module and not execute it, you can use the <code class="markup--code markup--p-code">require.resolve</code> function. This behaves exactly the same as the main <code class="markup--code markup--p-code">require</code> function, but does not load the file. It will still throw an error if the file does not exist and it will return the full path to the file when found.</p><pre name="82ea" id="82ea" class="graf graf--pre graf-after--p">&gt; require.resolve(&#39;find-me&#39;);<br>&#39;/Users/samer/learn-node/node_modules/find-me/start.js&#39;<br>&gt; require.resolve(&#39;not-there&#39;);<br>Error: Cannot find module &#39;not-there&#39;<br>    at Function.Module._resolveFilename (module.js:470:15)<br>    at Function.resolve (internal/module.js:27:19)<br>    at repl:1:9<br>    at ContextifyScript.Script.runInThisContext (vm.js:23:33)<br>    at REPLServer.defaultEval (repl.js:336:29)<br>    at bound (domain.js:280:14)<br>    at REPLServer.runBound [as eval] (domain.js:293:12)<br>    at REPLServer.onLine (repl.js:533:10)<br>    at emitOne (events.js:101:20)<br>    at REPLServer.emit (events.js:191:7)<br>&gt;</pre>
                                        <p name="36b2" id="36b2" class="graf graf--p graf-after--pre">This can be used, for example, to check whether an optional package is installed or not and only use it when it’s available.</p>
                                        <h4 name="ca42" id="ca42" class="graf graf--h4 graf-after--p">Relative and absolute paths</h4>
                                        <p name="5450" id="5450" class="graf graf--p graf-after--h4">Besides resolving modules from within the <code class="markup--code markup--p-code">node_modules</code> directories, we can also place the module anywhere we want and require it with either relative paths (<code class="markup--code markup--p-code">./</code> and <code class="markup--code markup--p-code">../</code>) or with absolute paths starting with <code class="markup--code markup--p-code">/</code>.</p>
                                        <p name="efbb" id="efbb" class="graf graf--p graf-after--p">If, for example, the <code class="markup--code markup--p-code">find-me.js</code> file was under a <code class="markup--code markup--p-code">lib</code> folder instead of the <code class="markup--code markup--p-code">node_modules</code> folder, we can require it with:</p><pre name="00b2" id="00b2" class="graf graf--pre graf-after--p">require(&#39;./lib/find-me&#39;);</pre>
                                        <h4 name="c705" id="c705" class="graf graf--h4 graf-after--pre">Parent-child relation between files</h4>
                                        <p name="a99b" id="a99b" class="graf graf--p graf-after--h4">Create a <code class="markup--code markup--p-code">lib/util.js</code> file and add a <code class="markup--code markup--p-code">console.log</code> line there to identify it. Also, <code class="markup--code markup--p-code">console.log</code> the <code class="markup--code markup--p-code">module</code> object itself:</p><pre name="43f2" id="43f2" class="graf graf--pre graf-after--p">~/learn-node $ mkdir lib<br>~/learn-node $ echo &quot;console.log(&#39;In util&#39;, module);&quot; &gt; lib/util.js</pre>
                                        <p name="6ff3" id="6ff3" class="graf graf--p graf-after--pre">Do the same for an <code class="markup--code markup--p-code">index.js</code> file, which is what we’ll be executing with the node command. Make this <code class="markup--code markup--p-code">index.js</code> file require <code class="markup--code markup--p-code">lib/util.js</code>:</p><pre name="8cbe" id="8cbe" class="graf graf--pre graf-after--p">~/learn-node $ echo &quot;console.log(&#39;In index&#39;, module); require(&#39;./lib/util&#39;);&quot; &gt; index.js</pre>
                                        <p name="bf95" id="bf95" class="graf graf--p graf-after--pre">Now execute the <code class="markup--code markup--p-code">index.js</code> file with node:</p><pre name="32fa" id="32fa" class="graf graf--pre graf-after--p">~/learn-node $ node index.js<br>In index Module {<br>  id: &#39;.&#39;,<br>  exports: {},<br>  parent: null,<br>  filename: &#39;/Users/samer/learn-node/index.js&#39;,<br>  loaded: false,<br>  children: [],<br>  paths: [ ... ] }<br>In util Module {<br>  id: &#39;/Users/samer/learn-node/lib/util.js&#39;,<br>  exports: {},<br>  parent:<br>   Module {<br>     id: &#39;.&#39;,<br>     exports: {},<br>     parent: null,<br>     filename: &#39;/Users/samer/learn-node/index.js&#39;,<br>     loaded: false,<br>     children: [ [Circular] ],<br>     paths: [...] },<br>  filename: &#39;/Users/samer/learn-node/lib/util.js&#39;,<br>  loaded: false,<br>  children: [],<br>  paths: [...] }</pre>
                                        <p name="80f3" id="80f3" class="graf graf--p graf-after--pre">Note how the main <code class="markup--code markup--p-code">index</code> module <code class="markup--code markup--p-code">(id: &#39;.&#39;)</code> is now listed as the parent for the <code class="markup--code markup--p-code">lib/util</code> module. However, the <code class="markup--code markup--p-code">lib/util</code> module was not listed as a child of the <code class="markup--code markup--p-code">index</code> module. Instead, we have the <code class="markup--code markup--p-code">[Circular]</code> value there because this is a circular reference. If Node prints the <code class="markup--code markup--p-code">lib/util</code> module object, it will go into an infinite loop. That’s why it simply replaces the <code class="markup--code markup--p-code">lib/util</code> reference with <code class="markup--code markup--p-code">[Circular]</code>.</p>
                                        <p name="4c58" id="4c58" class="graf graf--p graf-after--p">More importantly now, what happens if the <code class="markup--code markup--p-code">lib/util</code> module required the main <code class="markup--code markup--p-code">index</code> module? This is where we get into what’s known as the circular modular dependency, which is allowed in Node.</p>
                                        <p name="ad34" id="ad34" class="graf graf--p graf-after--p">To understand it better, let’s first understand a few other concepts on the module object.</p>
                                        <h4 name="fc14" id="fc14" class="graf graf--h4 graf-after--p">exports, module.exports, and synchronous loading of modules</h4>
                                        <p name="5a6a" id="5a6a" class="graf graf--p graf-after--h4">In any module, exports is a special object. If you’ve noticed above, every time we’ve printed a module object, it had an exports property which has been an empty object so far. We can add any attribute to this special exports object. For example, let’s export an id attribute for <code class="markup--code markup--p-code">index.js</code> and <code class="markup--code markup--p-code">lib/util.js</code>:</p><pre name="04a9" id="04a9" class="graf graf--pre graf-after--p">// Add the following line at the top of lib/util.js<br>exports.id = &#39;lib/util&#39;;</pre><pre name="500c" id="500c" class="graf graf--pre graf-after--pre">// Add the following line at the top of index.js<br>exports.id = &#39;index&#39;;</pre>
                                        <p name="d7f4" id="d7f4" class="graf graf--p graf-after--pre">When we now execute <code class="markup--code markup--p-code">index.js</code>, we’ll see these attributes as managed on each file’s <code class="markup--code markup--p-code">module</code> object:</p><pre name="62ef" id="62ef" class="graf graf--pre graf-after--p">~/learn-node $ node index.js<br>In index Module {<br>  id: &#39;.&#39;,<br>  exports: { id: &#39;index&#39; },<br>  loaded: false,<br>  ... }<br>In util Module {<br>  id: &#39;/Users/samer/learn-node/lib/util.js&#39;,<br>  exports: { id: &#39;lib/util&#39; },<br>  parent:<br>   Module {<br>     id: &#39;.&#39;,<br>     exports: { id: &#39;index&#39; },<br>     loaded: false,<br>     ... },<br>  loaded: false,<br>  ... }</pre>
                                        <p name="0f97" id="0f97" class="graf graf--p graf-after--pre">I’ve removed some attributes in the above output to keep it brief, but note how the <code class="markup--code markup--p-code">exports</code> object now has the attributes we defined in each module. You can put as many attributes as you want on that exports object, and you can actually change the whole object to be something else. For example, to change the exports object to be a function instead of an object, we do the following:</p><pre name="2eb8" id="2eb8" class="graf graf--pre graf-after--p">// Add the following line in index.js before the console.log </pre><pre name="55b9" id="55b9" class="graf graf--pre graf-after--pre">module.exports = function() {};</pre>
                                        <p name="1b84" id="1b84" class="graf graf--p graf-after--pre">When you run <code class="markup--code markup--p-code">index.js</code> now, you’ll see how the <code class="markup--code markup--p-code">exports</code> object is a function:</p><pre name="bcaf" id="bcaf" class="graf graf--pre graf-after--p">~/learn-node $ node index.js<br>In index Module {<br>  id: &#39;.&#39;,<br>  exports: [Function],<br>  loaded: false,<br>  ... }</pre>
                                        <p name="fdd9" id="fdd9" class="graf graf--p graf-after--pre">Note how we did not do <code class="markup--code markup--p-code">exports = function() {}</code> to make the <code class="markup--code markup--p-code">exports</code> object into a function. We can’t actually do that because the <code class="markup--code markup--p-code">exports</code> variable inside each module is just a reference to <code class="markup--code markup--p-code">module.exports</code> which manages the exported properties. When we reassign the <code class="markup--code markup--p-code">exports</code> variable, that reference is lost and we would be introducing a new variable instead of changing the <code class="markup--code markup--p-code">module.exports</code> object.</p>
                                        <p name="016d" id="016d" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">module.exports</code> object in every module is what the <code class="markup--code markup--p-code">require</code> function returns when we require that module. For example, change the <code class="markup--code markup--p-code">require(&#39;./lib/util&#39;)</code> line in <code class="markup--code markup--p-code">index.js</code> into:</p><pre name="8c54" id="8c54" class="graf graf--pre graf-after--p">const UTIL = require(&#39;./lib/util&#39;);</pre><pre name="73f2" id="73f2" class="graf graf--pre graf-after--pre">console.log(&#39;UTIL:&#39;, UTIL);</pre>
                                        <p name="5454" id="5454" class="graf graf--p graf-after--pre">The above will capture the properties exported in <code class="markup--code markup--p-code">lib/util</code> into the <code class="markup--code markup--p-code">UTIL</code> constant. When we run <code class="markup--code markup--p-code">index.js</code> now, the very last line will output:</p><pre name="639b" id="639b" class="graf graf--pre graf-after--p">UTIL: { id: &#39;lib/util&#39; }</pre>
                                        <p name="20d4" id="20d4" class="graf graf--p graf-after--pre">Let’s also talk about the <code class="markup--code markup--p-code">loaded</code> attribute on every module. So far, every time we printed a module object, we saw a <code class="markup--code markup--p-code">loaded</code> attribute on that object with a value of <code class="markup--code markup--p-code">false</code>.</p>
                                        <p name="d877" id="d877" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">module</code> module uses the <code class="markup--code markup--p-code">loaded</code> attribute to track which modules have been loaded (true value) and which modules are still being loaded (false value). We can, for example, see the <code class="markup--code markup--p-code">index.js</code> module fully loaded if we print its <code class="markup--code markup--p-code">module</code> object on the next cycle of the event loop using a <code class="markup--code markup--p-code">setImmediate</code> call:</p><pre name="6d06" id="6d06" class="graf graf--pre graf-after--p">// In index.js<br>setImmediate(() =&gt; {<br>  console.log(&#39;The index.js module object is now loaded!&#39;, module)<br>});</pre>
                                        <p name="9726" id="9726" class="graf graf--p graf-after--pre">The output of that would be:</p><pre name="3096" id="3096" class="graf graf--pre graf-after--p">The index.js module object is now loaded! Module {<br>  id: &#39;.&#39;,<br>  exports: [Function],<br>  parent: null,<br>  filename: &#39;/Users/samer/learn-node/index.js&#39;,<br><strong class="markup--strong markup--pre-strong">  loaded: true,<br></strong>  children:<br>   [ Module {<br>       id: &#39;/Users/samer/learn-node/lib/util.js&#39;,<br>       exports: [Object],<br>       parent: [Circular],<br>       filename: &#39;/Users/samer/learn-node/lib/util.js&#39;,<br><strong class="markup--strong markup--pre-strong">       loaded: true,<br></strong>       children: [],<br>       paths: [Object] } ],<br>  paths:<br>   [ &#39;/Users/samer/learn-node/node_modules&#39;,<br>     &#39;/Users/samer/node_modules&#39;,<br>     &#39;/Users/node_modules&#39;,<br>     &#39;/node_modules&#39; ] }</pre>
                                        <p name="c69c" id="c69c" class="graf graf--p graf-after--pre">Note how in this delayed <code class="markup--code markup--p-code">console.log</code> output both <code class="markup--code markup--p-code">lib/util.js</code> and <code class="markup--code markup--p-code">index.js</code> are fully loaded.</p>
                                        <p name="7ddc" id="7ddc" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">exports</code> object becomes complete when Node finishes loading the module (and labels it so). The whole process of requiring/loading a module is <em class="markup--em markup--p-em">synchronous.</em> That’s why we were able to see the modules fully loaded after one cycle of the event loop.</p>
                                        <p name="3695" id="3695" class="graf graf--p graf-after--p">This also means that we cannot change the <code class="markup--code markup--p-code">exports</code> object asynchronously. We can’t, for example, do the following in any module:</p><pre name="4921" id="4921" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">fs.readFile(&#39;/etc/passwd&#39;, (err, data) =&gt; {<br>  if (err) throw err;</code></pre><pre name="9c17" id="9c17" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><strong class="markup--strong markup--pre-strong">  exports.data = data; // Will not work.</strong><br>});</code></pre>
                                        <h4 name="c67c" id="c67c" class="graf graf--h4 graf-after--pre">Circular module dependency</h4>
                                        <p name="2075" id="2075" class="graf graf--p graf-after--h4">Let’s now try to answer the important question about circular dependency in Node: What happens when module 1 requires module 2, and module 2 requires module 1?</p>
                                        <p name="f635" id="f635" class="graf graf--p graf-after--p">To find out, let’s create the following two files under <code class="markup--code markup--p-code">lib/</code>, <code class="markup--code markup--p-code">module1.js</code> and <code class="markup--code markup--p-code">module2.js</code> and have them require each other:</p><pre name="306e" id="306e" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">// lib/module1.js</strong></pre><pre name="8157" id="8157" class="graf graf--pre graf-after--pre">exports.a = 1;</pre><pre name="6182" id="6182" class="graf graf--pre graf-after--pre">require(&#39;./module2&#39;);</pre><pre name="c5e2" id="c5e2" class="graf graf--pre graf-after--pre">exports.b = 2;<br>exports.c = 3;</pre><pre name="d4ef" id="d4ef" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong"><br>// lib/module2.js</strong></pre><pre name="5a4e" id="5a4e" class="graf graf--pre graf-after--pre">const Module1 = require(&#39;./module1&#39;);<br>console.log(&#39;Module1 is partially loaded here&#39;, Module1);</pre>
                                        <p name="96e8" id="96e8" class="graf graf--p graf-after--pre">When we run <code class="markup--code markup--p-code">module1.js</code> we see the following:</p><pre name="b64c" id="b64c" class="graf graf--pre graf-after--p">~/learn-node $ node lib/module1.js<br>Module1 is partially loaded here { a: 1 }</pre>
                                        <p name="02c6" id="02c6" class="graf graf--p graf-after--pre">We required <code class="markup--code markup--p-code">module2</code> before <code class="markup--code markup--p-code">module1</code> was fully loaded, and since <code class="markup--code markup--p-code">module2</code> required <code class="markup--code markup--p-code">module1</code> while it wasn’t fully loaded, what we get from the <code class="markup--code markup--p-code">exports</code> object at that point are all the properties exported prior to the circular dependency. Only the <code class="markup--code markup--p-code">a</code> property was reported because both <code class="markup--code markup--p-code">b</code> and <code class="markup--code markup--p-code">c</code> were exported after <code class="markup--code markup--p-code">module2</code> required and printed <code class="markup--code markup--p-code">module1</code>.</p>
                                        <p name="3c63" id="3c63" class="graf graf--p graf-after--p">Node keeps this really simple. During the loading of a module, it builds the <code class="markup--code markup--p-code">exports</code> object. You can require the module before it’s done loading and you’ll just get a partial exports object with whatever was defined so far.</p>
                                        <h4 name="a806" id="a806" class="graf graf--h4 graf-after--p">JSON and C/C++ addons</h4>
                                        <p name="9de3" id="9de3" class="graf graf--p graf-after--h4">We can natively require JSON files and C++ addon files with the require function. You don’t even need to specify a file extension to do so.</p>
                                        <p name="00db" id="00db" class="graf graf--p graf-after--p">If a file extension was not specified, the first thing Node will try to resolve is a <code class="markup--code markup--p-code">.js</code> file. If it can’t find a <code class="markup--code markup--p-code">.js</code> file, it will try a <code class="markup--code markup--p-code">.json</code> file and it will parse the <code class="markup--code markup--p-code">.json</code> file if found as a JSON text file. After that, it will try to find a binary <code class="markup--code markup--p-code">.node</code> file. However, to remove ambiguity, you should probably specify a file extension when requiring anything other than <code class="markup--code markup--p-code">.js</code> files.</p>
                                        <p name="f330" id="f330" class="graf graf--p graf-after--p">Requiring JSON files is useful if, for example, everything you need to manage in that file is some static configuration values, or some values that you periodically read from an external source. For example, if we had the following <code class="markup--code markup--p-code">config.json</code> file:</p><pre name="0341" id="0341" class="graf graf--pre graf-after--p">{<br>  &quot;host&quot;: &quot;localhost&quot;,<br>  &quot;port&quot;: 8080<br>}</pre>
                                        <p name="051a" id="051a" class="graf graf--p graf-after--pre">We can require it directly like this:</p><pre name="e4f5" id="e4f5" class="graf graf--pre graf-after--p">const { host, port } = require(&#39;./config&#39;);</pre><pre name="8092" id="8092" class="graf graf--pre graf-after--pre">console.log(`Server will run at <a href="http://$%7Bhost%7D:$%7Bport%7D`" data-href="http://${host}:${port}`" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">http://${host}:${port}`</a>);</pre>
                                        <p name="0268" id="0268" class="graf graf--p graf-after--pre">Running the above code will have this output:</p><pre name="609d" id="609d" class="graf graf--pre graf-after--p">Server will run at <a href="http://localhost:8080" data-href="http://localhost:8080" class="markup--anchor markup--pre-anchor" rel="nofollow" target="_blank">http://localhost:8080</a></pre>
                                        <p name="b980" id="b980" class="graf graf--p graf-after--pre">If Node can’t find a <code class="markup--code markup--p-code">.js</code> or a <code class="markup--code markup--p-code">.json</code> file, it will look for a <code class="markup--code markup--p-code">.node</code> file and it would interpret the file as a compiled addon module.</p>
                                        <p name="c992" id="c992" class="graf graf--p graf-after--p">The Node documentation site has a <a href="https://nodejs.org/api/addons.html#addons_hello_world" data-href="https://nodejs.org/api/addons.html#addons_hello_world" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">sample addon file</a> which is written in C++. It’s a simple module that exposes a <code class="markup--code markup--p-code">hello()</code> function and the hello function outputs “world.”</p>
                                        <p name="d1fd" id="d1fd" class="graf graf--p graf-after--p">You can use the <code class="markup--code markup--p-code">node-gyp</code> package to compile and build the <code class="markup--code markup--p-code">.cc</code> file into a <code class="markup--code markup--p-code">.addon</code> file. You just need to configure a <a href="https://nodejs.org/api/addons.html#addons_building" data-href="https://nodejs.org/api/addons.html#addons_building" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">binding.gyp</a> file to tell <code class="markup--code markup--p-code">node-gyp</code> what to do.</p>
                                        <p name="b432" id="b432" class="graf graf--p graf-after--p">Once you have the <code class="markup--code markup--p-code">addon.node</code> file (or whatever name you specify in <code class="markup--code markup--p-code">binding.gyp</code>) then you can natively require it just like any other module:</p><pre name="7563" id="7563" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">const addon = require(&#39;./addon&#39;);</code></pre><pre name="760d" id="760d" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">console.log(addon.hello());</code></pre>
                                        <p name="c095" id="c095" class="graf graf--p graf-after--pre">We can actually see the support of the three extensions by looking at <code class="markup--code markup--p-code">require.extensions</code>.</p>
                                        <figure name="4598" id="4598" class="graf graf--figure graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 388px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 55.50000000000001%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*IcpIrifyQIn9M0q8scMZdA.png" data-width="2820" data-height="1564" data-action="zoom" data-action-value="1*IcpIrifyQIn9M0q8scMZdA.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*IcpIrifyQIn9M0q8scMZdA.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/800/1*IcpIrifyQIn9M0q8scMZdA.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/800/1*IcpIrifyQIn9M0q8scMZdA.png"></noscript>
                                                </div>
                                            </div>
                                        </figure>
                                        <p name="a3af" id="a3af" class="graf graf--p graf-after--figure">Looking at the functions for each extension, you can clearly see what Node will do with each. It uses <code class="markup--code markup--p-code">module._compile</code> for <code class="markup--code markup--p-code">.js</code> files, <code class="markup--code markup--p-code">JSON.parse</code> for <code class="markup--code markup--p-code">.json</code> files, and <code class="markup--code markup--p-code">process.dlopen</code> for <code class="markup--code markup--p-code">.node</code> files.</p>
                                        <h4 name="cff2" id="cff2" class="graf graf--h4 graf-after--p">All code you write in Node will be wrapped in functions</h4>
                                        <p name="e9ca" id="e9ca" class="graf graf--p graf-after--h4">Node’s wrapping of modules is often misunderstood. To understand it, let me remind you about the <code class="markup--code markup--p-code">exports</code>/<code class="markup--code markup--p-code">module.exports</code> relation.</p>
                                        <p name="8ef7" id="8ef7" class="graf graf--p graf-after--p">We can use the <code class="markup--code markup--p-code">exports</code> object to export properties, but we cannot replace the <code class="markup--code markup--p-code">exports</code> object directly because it’s just a reference to <code class="markup--code markup--p-code">module.exports</code></p><pre name="4ea0" id="4ea0" class="graf graf--pre graf-after--p">exports.id = 42; // This is ok.</pre><pre name="e970" id="e970" class="graf graf--pre graf-after--pre">exports = { id: 42 }; // This will not work.</pre><pre name="896b" id="896b" class="graf graf--pre graf-after--pre">module.exports = { id: 42 }; // This is ok.</pre>
                                        <p name="dd00" id="dd00" class="graf graf--p graf-after--pre">How exactly does this <code class="markup--code markup--p-code">exports</code> object, which appears to be global for every module, get defined as a reference on the <code class="markup--code markup--p-code">module</code> object?</p>
                                        <p name="ddf4" id="ddf4" class="graf graf--p graf-after--p">Let me ask one more question before explaining Node’s wrapping process.</p>
                                        <p name="43fd" id="43fd" class="graf graf--p graf-after--p">In a browser, when we declare a variable in a script like this:</p><pre name="e3b2" id="e3b2" class="graf graf--pre graf-after--p">var answer = 42;</pre>
                                        <p name="652c" id="652c" class="graf graf--p graf-after--pre">That <code class="markup--code markup--p-code">answer</code> variable will be globally available in all scripts after the script that defined it.</p>
                                        <p name="1ec0" id="1ec0" class="graf graf--p graf-after--p">This is not the case in Node. When we define a variable in one module, the other modules in the program will not have access to that variable. So how come variables in Node are magically scoped?</p>
                                        <p name="b9ec" id="b9ec" class="graf graf--p graf-after--p">The answer is simple. Before compiling a module, Node wraps the module code in a function, which we can inspect using the <code class="markup--code markup--p-code">wrapper</code> property of the <code class="markup--code markup--p-code">module</code> module.</p><pre name="0692" id="0692" class="graf graf--pre graf-after--p">~ $ node<br>&gt; require(&#39;module&#39;).wrapper<br>[ &#39;(function (exports, require, module, __filename, __dirname) { &#39;,<br>  &#39;\n});&#39; ]<br>&gt;</pre>
                                        <p name="9ddb" id="9ddb" class="graf graf--p graf-after--pre">Node does not execute any code you write in a file directly. It executes this wrapper function which will have your code in its body. This is what keeps the top-level variables that are defined in any module scoped to that module.</p>
                                        <p name="3a69" id="3a69" class="graf graf--p graf-after--p">This wrapper function has 5 arguments: <code class="markup--code markup--p-code">exports</code>, <code class="markup--code markup--p-code">require</code>, <code class="markup--code markup--p-code">module</code>, <code class="markup--code markup--p-code">__filename</code>, and <code class="markup--code markup--p-code">__dirname</code>. This is what makes them appear to look global when in fact they are specific to each module.</p>
                                        <p name="45ed" id="45ed" class="graf graf--p graf-after--p">All of these arguments get their values when Node executes the wrapper function. <code class="markup--code markup--p-code">exports</code> is defined as a reference to <code class="markup--code markup--p-code">module.exports</code> prior to that. <code class="markup--code markup--p-code">require</code> and <code class="markup--code markup--p-code">module</code> are both specific to the function to be executed, and <code class="markup--code markup--p-code">__filename</code>/<code class="markup--code markup--p-code">__dirname</code> variables will contain the wrapped module’s absolute filename and directory path.</p>
                                        <p name="4c99" id="4c99" class="graf graf--p graf-after--p">You can see this wrapping in action if you run a script with a problem on its first line:</p><pre name="29f9" id="29f9" class="graf graf--pre graf-after--p">~/learn-node $ echo &quot;euaohseu&quot; &gt; bad.js</pre><pre name="44cd" id="44cd" class="graf graf--pre graf-after--pre">~/learn-node $ node bad.js<br>~/bad.js:1<br>(function (exports, require, module, __filename, __dirname) { euaohseu<br>                                                              ^</pre><pre name="9a8f" id="9a8f" class="graf graf--pre graf-after--pre">ReferenceError: euaohseu is not defined</pre>
                                        <p name="21ca" id="21ca" class="graf graf--p graf-after--pre">Note how the first line of the script as reported above was the wrapper function, not the bad reference.</p>
                                        <p name="5413" id="5413" class="graf graf--p graf-after--p">Moreover, since every module gets wrapped in a function, we can actually access that function’s arguments with the <code class="markup--code markup--p-code">arguments</code> keyword:</p><pre name="8e4c" id="8e4c" class="graf graf--pre graf-after--p">~/learn-node $ echo &quot;console.log(arguments)&quot; &gt; index.js</pre><pre name="41dc" id="41dc" class="graf graf--pre graf-after--pre">~/learn-node $ node index.js<br>{ &#39;0&#39;: {},<br>  &#39;1&#39;:<br>   { [Function: require]<br>     resolve: [Function: resolve],<br>     main:<br>      Module {<br>        id: &#39;.&#39;,<br>        exports: {},<br>        parent: null,<br>        filename: &#39;/Users/samer/index.js&#39;,<br>        loaded: false,<br>        children: [],<br>        paths: [Object] },<br>     extensions: { ... },<br>     cache: { &#39;/Users/samer/index.js&#39;: [Object] } },<br>  &#39;2&#39;:<br>   Module {<br>     id: &#39;.&#39;,<br>     exports: {},<br>     parent: null,<br>     filename: &#39;/Users/samer/index.js&#39;,<br>     loaded: false,<br>     children: [],<br>     paths: [ ... ] },<br>  &#39;3&#39;: &#39;/Users/samer/index.js&#39;,<br>  &#39;4&#39;: &#39;/Users/samer&#39; }</pre>
                                        <p name="c4d8" id="c4d8" class="graf graf--p graf-after--pre">The first argument is the <code class="markup--code markup--p-code">exports</code> object, which starts empty. Then we have the <code class="markup--code markup--p-code">require</code>/<code class="markup--code markup--p-code">module</code> objects, both of which are instances that are associated with the <code class="markup--code markup--p-code">index.js</code> file that we’re executing. They are not global variables. The last 2 arguments are the file’s path and its directory path.</p>
                                        <p name="a023" id="a023" class="graf graf--p graf-after--p">The wrapping function’s return value is <code class="markup--code markup--p-code">module.exports</code>. Inside the wrapped function, we can use the <code class="markup--code markup--p-code">exports</code> object to change the properties of <code class="markup--code markup--p-code">module.exports</code>, but we can’t reassign exports itself because it’s just a reference.</p>
                                        <p name="dc27" id="dc27" class="graf graf--p graf-after--p">What happens is roughly equivalent to:</p><pre name="9abc" id="9abc" class="graf graf--pre graf-after--p">function (require, module, __filename, __dirname) {<br>  let exports = module.exports;</pre><pre name="7121" id="7121" class="graf graf--pre graf-after--pre">  // Your Code...</pre><pre name="9a88" id="9a88" class="graf graf--pre graf-after--pre">  return module.exports;<br>}</pre>
                                        <p name="aeb2" id="aeb2" class="graf graf--p graf-after--pre">If we change the whole <code class="markup--code markup--p-code">exports</code> object, it would no longer be a reference to <code class="markup--code markup--p-code">module.exports</code>. This is the way JavaScript reference objects work everywhere, not just in this context.</p>
                                        <h4 name="7a08" id="7a08" class="graf graf--h4 graf-after--p">The require object</h4>
                                        <p name="6a07" id="6a07" class="graf graf--p graf-after--h4">There is nothing special about <code class="markup--code markup--p-code">require</code>. It’s an object that acts mainly as a function that takes a module name or path and returns the <code class="markup--code markup--p-code">module.exports</code> object. We can simply override the <code class="markup--code markup--p-code">require</code> object with our own logic if we want to.</p>
                                        <p name="f500" id="f500" class="graf graf--p graf-after--p">For example, maybe for testing purposes, we want every <code class="markup--code markup--p-code">require</code> call to be mocked by default and just return a fake object instead of the required module exports object. This simple reassignment of require will do the trick:</p><pre name="d5f4" id="d5f4" class="graf graf--pre graf-after--p">require = function() {</pre><pre name="99bf" id="99bf" class="graf graf--pre graf-after--pre">  return { mocked: true };</pre><pre name="d6b9" id="d6b9" class="graf graf--pre graf-after--pre">}</pre>
                                        <p name="dd13" id="dd13" class="graf graf--p graf-after--pre">After doing the above reassignment of <code class="markup--code markup--p-code">require</code>, every <code class="markup--code markup--p-code">require(&#39;something&#39;) </code>call in the script will just return the mocked object.</p>
                                        <p name="a7e6" id="a7e6" class="graf graf--p graf-after--p">The require object also has properties of its own. We’ve seen the <code class="markup--code markup--p-code">resolve</code> property, which is a function that performs only the resolving step of the require process. We’ve also seen <code class="markup--code markup--p-code">require.extensions</code> above.</p>
                                        <p name="f20b" id="f20b" class="graf graf--p graf-after--p">There is also <code class="markup--code markup--p-code">require.main</code> which can be helpful to determine if the script is being required or run directly.</p>
                                        <p name="60db" id="60db" class="graf graf--p graf-after--p">Say, for example, that we have this simple <code class="markup--code markup--p-code">printInFrame</code> function in <code class="markup--code markup--p-code">print-in-frame.js</code>:</p><pre name="3e20" id="3e20" class="graf graf--pre graf-after--p">// In print-in-frame.js</pre><pre name="cce2" id="cce2" class="graf graf--pre graf-after--pre">const printInFrame = (size, header) =&gt; {<br>  console.log(&#39;*&#39;.repeat(size));<br>  console.log(header);<br>  console.log(&#39;*&#39;.repeat(size));<br>};</pre>
                                        <p name="2709" id="2709" class="graf graf--p graf-after--pre">The function takes a numeric argument <code class="markup--code markup--p-code">size</code> and a string argument <code class="markup--code markup--p-code">header</code> and it prints that header in a frame of stars controlled by the size we specify.</p>
                                        <p name="603b" id="603b" class="graf graf--p graf-after--p">We want to use this file in two ways:</p>
                                        <ol class="postList">
                                            <li name="ec80" id="ec80" class="graf graf--li graf-after--p">From the command line directly like this:</li>
                                        </ol><pre name="8ec5" id="8ec5" class="graf graf--pre graf-after--li">~/learn-node $ node print-in-frame 8 Hello</pre>
                                        <p name="1533" id="1533" class="graf graf--p graf-after--pre">Passing 8 and Hello as command line arguments to print “Hello” in a frame of 8 stars.</p>
                                        <p name="32e9" id="32e9" class="graf graf--p graf-after--p">2. With <code class="markup--code markup--p-code">require</code>. Assuming the required module will export the <code class="markup--code markup--p-code">printInFrame</code> function and we can just call it:</p><pre name="851a" id="851a" class="graf graf--pre graf-after--p">const print = require(&#39;./print-in-frame&#39;);</pre><pre name="93a4" id="93a4" class="graf graf--pre graf-after--pre">print(5, &#39;Hey&#39;);</pre>
                                        <p name="9399" id="9399" class="graf graf--p graf-after--pre">To print the header “Hey” in a frame of 5 stars.</p>
                                        <p name="3333" id="3333" class="graf graf--p graf-after--p">Those are two different usages. We need a way to determine if the file is being run as a stand-alone script or if it is being required by other scripts.</p>
                                        <p name="64fa" id="64fa" class="graf graf--p graf-after--p">This is where we can use this simple if statement:</p><pre name="0790" id="0790" class="graf graf--pre graf-after--p">if (require.main === module) {<br>  // The file is being executed directly (not with require)<br>}</pre>
                                        <p name="505b" id="505b" class="graf graf--p graf-after--pre">So we can use this condition to satisfy the usage requirements above by invoking the printInFrame function differently:</p><pre name="214c" id="214c" class="graf graf--pre graf-after--p">// In print-in-frame.js</pre><pre name="e1bd" id="e1bd" class="graf graf--pre graf-after--pre">const printInFrame = (size, header) =&gt; {<br>  console.log(&#39;*&#39;.repeat(size));<br>  console.log(header);<br>  console.log(&#39;*&#39;.repeat(size));<br>};</pre><pre name="d726" id="d726" class="graf graf--pre graf-after--pre">if (require.main === module) {<br>  printInFrame(process.argv[2], process.argv[3]);<br>} else {<br>  module.exports = printInFrame;<br>}</pre>
                                        <p name="b2bf" id="b2bf" class="graf graf--p graf-after--pre">When the file is not being required, we just call the <code class="markup--code markup--p-code">printInFrame</code> function with <code class="markup--code markup--p-code">process.argv</code> elements. Otherwise, we just change the <code class="markup--code markup--p-code">module.exports</code> object to be the <code class="markup--code markup--p-code">printInFrame</code> function itself.</p>
                                        <h4 name="af5b" id="af5b" class="graf graf--h4 graf-after--p">All modules will be cached</h4>
                                        <p name="c9e5" id="c9e5" class="graf graf--p graf-after--h4">Caching is important to understand. Let me use a simple example to demonstrate it.</p>
                                        <p name="56d2" id="56d2" class="graf graf--p graf-after--p">Say that you have the following <code class="markup--code markup--p-code">ascii-art.js</code> file that prints a cool looking header:</p>
                                    </div>
                                    <div class="section-inner sectionLayout--outsetColumn">
                                        <figure name="9aab" id="9aab" class="graf graf--figure graf--layoutOutsetCenter graf-after--p">
                                            <div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 276px;">
                                                <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 27.6%;"></div>
                                                <div class="progressiveMedia js-progressiveMedia graf-image" data-image-id="1*yZ57VtXUuEo-nQSs9VztvQ.png" data-width="2116" data-height="584" data-action="zoom" data-action-value="1*yZ57VtXUuEo-nQSs9VztvQ.png"><img src="https://cdn-images-1.medium.com/freeze/max/30/1*yZ57VtXUuEo-nQSs9VztvQ.png?q=20" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">
                                                    <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/1000/1*yZ57VtXUuEo-nQSs9VztvQ.png">
                                                    <noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1000/1*yZ57VtXUuEo-nQSs9VztvQ.png"></noscript>
                                                </div>
                                            </div>
                                        </figure>
                                    </div>
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="6ef5" id="6ef5" class="graf graf--p graf-after--figure">We want to display this header every time we <em class="markup--em markup--p-em">require</em> the file. So when we require the file twice, we want the header to show up twice.</p><pre name="7d50" id="7d50" class="graf graf--pre graf-after--p">require(&#39;./ascii-art&#39;) // will show the header.<br>require(&#39;./ascii-art&#39;) // will not show the header.</pre>
                                        <p name="3b62" id="3b62" class="graf graf--p graf-after--pre">The second require will not show the header because of modules’ caching. Node caches the first call and does not load the file on the second call.</p>
                                        <p name="a303" id="a303" class="graf graf--p graf-after--p">We can see this cache by printing <code class="markup--code markup--p-code">require.cache</code> after the first require. The cache registry is simply an object that has a property for every required module. Those properties values are the <code class="markup--code markup--p-code">module</code> objects used for each module. We can simply delete a property from that <code class="markup--code markup--p-code">require.cache</code> object to invalidate that cache. If we do that, Node will re-load the module to re-cache it.</p>
                                        <p name="da62" id="da62" class="graf graf--p graf-after--p">However, this is not the most efficient solution for this case. The simple solution is to wrap the log line in <code class="markup--code markup--p-code">ascii-art.js</code> with a function and export that function. This way, when we require the <code class="markup--code markup--p-code">ascii-art.js</code> file, we get a function that we can execute to invoke the log line every time:</p><pre name="e165" id="e165" class="graf graf--pre graf-after--p">require(&#39;./ascii-art&#39;)() // will show the header.<br>require(&#39;./ascii-art&#39;)() // will also show the header.</pre>
                                        <p name="45c8" id="45c8" class="graf graf--p graf-after--pre graf--trailing">That’s all I have for this topic. Thanks for reading. Until next time!</p>
                                    </div>
                                </div>
                            </section>
                            <section name="8e68" class="section section--body section--last">
                                <div class="section-divider">
                                    <hr class="section-divider">
                                </div>
                                <div class="section-content">
                                    <div class="section-inner sectionLayout--insetColumn">
                                        <p name="5ffe" id="5ffe" class="graf graf--p graf--leading">I create <strong class="markup--strong markup--p-strong">online courses</strong> for <a href="https://app.pluralsight.com/profile/author/samer-buna" data-href="https://app.pluralsight.com/profile/author/samer-buna" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Pluralsight</a> and <a href="https://www.lynda.com/Samer-Buna/7060467-1.html" data-href="https://www.lynda.com/Samer-Buna/7060467-1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Lynda</a>. My most recent courses are <a href="https://www.pluralsight.com/courses/reactjs-advanced" data-href="https://www.pluralsight.com/courses/reactjs-advanced" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Advanced React.js</a>, <a href="https://www.pluralsight.com/courses/nodejs-advanced" data-href="https://www.pluralsight.com/courses/nodejs-advanced" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Advanced Node.js</a>, and <a href="https://www.lynda.com/Express-js-tutorials/Learning-Full-Stack-JavaScript-Development-MongoDB-Node-React/533304-2.html" data-href="https://www.lynda.com/Express-js-tutorials/Learning-Full-Stack-JavaScript-Development-MongoDB-Node-React/533304-2.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Learning Full-stack JavaScript</a>.</p>
                                        <p name="f899" id="f899" class="graf graf--p graf-after--p graf--trailing">I also do <strong class="markup--strong markup--p-strong">online and onsite training</strong> for groups covering beginner to advanced levels in JavaScript, Node.js, React.js, and GraphQL. <a href="mailto:samer@jscomplete.com" data-href="mailto:samer@jscomplete.com" class="markup--anchor markup--p-anchor" target="_blank">Drop me a line</a> if you’re looking for a trainer. If you have any questions about this article or any other article I wrote, find me on <a href="https://slack.jscomplete.com/" data-href="https://slack.jscomplete.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this <strong class="markup--strong markup--p-strong">slack</strong> account</a> (you can invite yourself) and ask in the #questions room.</p>
                                    </div>
                                </div>
                            </section>
                        </div>
